🚀 전략 패턴이란?
정책 패턴(Policy Pattern)이라고도 불림
알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 사용할 수 있게 해줌
객체의 행위를 변경하고 싶은 경우 직접 수정하지 않고 전략이라 불리는 캡슐화한 알고리즘을 변경해줌으로써 유연하게 확장하는 방법
 

🚀 강아지로 예시 코드 작성해보기
먼저 강아지를 만들어야한다고 생각합니다.

강아지는 다양하고, 각각 행동(소리와 움직임)이 다릅니다.

이 때 어떻게 코드를 작성할 수 있을까요?

1. 상속을 이용

상속을 이용
같은 행동을 하는 강아지들이라면 상관없지만 다른 행동을 하는 강아지들이 있을 수 있습니다.

코드 재사용성을 위해 상속을 이용하는 것도 좋지만, 불필요한 유지보수가 크게 늘어날 수 있습니다.

즉, 모든 서브클래스에서 같은 행동을 하는 것이 아니므로 상속을 이용한 방법은 X

 

2. 인터페이스를 이용

인터페이스를 이용해서 직접 구현
행동을 인터페이스로 분리시켜 강아지의 서브클래스들이 구현하게 합니다.

이 방법도 괜찮아보이지만 행동이 변경된다면 그것을 구현하는 모든 서브클래스의 코드를 고쳐야합니다.

또한 인터페이스는 구현된 코드가 없으므로 코드 재사용하기 어렵습니다.

즉, 행동을 변경할 때마다 행동을 구현한 서브클래스들을 전부 찾아서 일일이 고쳐야 합니다.

 

3. 캡슐화된 행동 이용

인터페이스를 이용하고 구현된 행동을 사용
2번에서는 행동을 인터페이스로 표현하고 이 인터페이스를 직접 구현했었습니다.

하지만 행동이 변경되면 구현된 클래스를 전부 일일이 수정해야하는 문제점이 있었습니다.

이 문제점을 해결하기 위해 행동 인터페이스를 구현한 행동 클래스를 만들고 그것을 사용합니다.

따라서 강아지 서브클래스들은 행동 인터페이스를 직접 구현할 필요가 없기에 문제가 해결됩니다.

중요한 점은 직접 구현하지 않는다는 것이지 사용하지 않는다는 것이 아닙니다.

 

이 방식을 사용한다면 다른 형식의 객체에서도 움직임 행동과 소리 행동을 재사용할 수 있음
기존 행동을 수정하거나 추가해도 Dog 클래스를 전혀 건드리지 않고 쉽게 변경 및 추가 가능
상속과 직접 구현의 문제점 해결하면서 재사용의 장점을 가짐
이 캡슐화된 행동을 이용하는 방법은 Dog 클래스 또는 Dog 서브클래스에서 해당 기능을 직접 구현하지 않고 행동 클래스에 위임(delegate)하고 있습니다. 따라서 저번에 배운 위임 패턴(Delegate Pattern)이 사용되고 있습니다.

 


Dog 추상 클래스

Bulldog 클래스 (Dog 서브클래스)

ToyDog 클래스 (Dog 서브클래스)

MoveBehavior 인터페이스

MoveNoWalk 클래스 (MoveBehavior 구현 클래스)

MoveWithWalk 클래스 (MoveBehavior 구현 클래스)

SoundBehavior 인터페이스

SoundDog 클래스 (SoundBehavior 구현 클래스)

SoundToy 클래스 (SoundBehavior 구현 클래스)

Test 코드
캡슐화된 행동을 이용한 전략패턴으로 테스트를 한 코드이다.

불독 객체를 생성하여 바로 사용했으며, 이후 소리도 setter 메서드로 손쉽게 변경가능하다. (동적 변경 가능)

이렇게 Dog 클래스가 두 행동을 상속 또는 구현하는게 아니라 구성(composition)되어 행동을 부여받는 전략 패턴을 사용해보았다.

 

위 코드는 여기를 클릭하면 나옴

 🚀 결론
장점
알고리즘을 정의하고 캡슐화하여 런타임 시에 알고리즘을 선택하는 데 사용됨
알고리즘을 쉽게 변경 및 대체할 수 있으므로 유연함
알고리즘 추가 및 수정을 할 때 코드 수정이 최소화되므로 확장성이 높아짐
알고리즘을 캡슐화했기에 코드 재사용성이 좋음
각각 알고리즘을 독립적으로 테스트할 수 있으므로 용이함
단점
추가적인 클래스 및 인터페이스가 필요하기에 코드 복잡성이 증가될 수 있음
런타임 시에 알고리즘을 선택하는 데 추가적인 오버헤드 발생 가능
전략패턴을 구현하는 것이 어려울 수 있으므로, 적절한 분석과 설계가 필요함
